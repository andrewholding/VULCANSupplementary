### Enrichment Loop C2
fname<-paste0("results/004_results_hypergeom_C2_",tf,".rda")
#pathways<-msigDBentrez$c2.cp.biocarta.v5.0.entrez.gmt
pathways<-msigDBentrez$c2.all.v5.0.entrez.gmt
if(!file.exists(fname)){
results<-list()
ntests<-0
tfs<-names(regulon)
pb<-txtProgressBar(0,length(tfs),style=3)
pbi<-1
for(tf in tfs){
plimit<-0.05
setTxtProgressBar(pb,pbi)
sublistUP<-setNames(rep(NA,length(pathways)),names(pathways))
sublistDN<-setNames(rep(NA,length(pathways)),names(pathways))
i<-1
for(pathway in pathways){
networkUP<-names(regulon[[tf]]$tfmode)[regulon[[tf]]$tfmode>=0]
networkDN<-names(regulon[[tf]]$tfmode)[regulon[[tf]]$tfmode<0]
pUP<-enrich(networkUP,pathway,ngenes)
pDN<-enrich(networkDN,pathway,ngenes)
ntests<-ntests+1
sublistUP[i]<-pUP
sublistDN[i]<-pDN
i<-i+1
}
sublistUP<-sublistUP[sublistUP<=plimit]
sublistDN<-sublistDN[sublistDN<=plimit]
results[[tf]]<-list(up=sublistUP,dn=sublistDN)
pbi<-pbi+1
}
save(results,ntests,file=fname)
} else {
load(fname)
}
### Now, plotting
# Set parameters
topn<-20
subsetting<-"REACTOME_"
## Start plot
# Prepare input results
res<-results[[s2e(tf)]]
# Correct pvalues and integrate
resUP<-p.adjust(res$up,method="none",n=ntests) # convert to bonferroni when deploying
resDN<-p.adjust(res$dn,method="none",n=ntests)
union<-union(names(resUP),names(resDN))
tmptable<-cbind(resUP[union],resDN[union])
tmptable[is.na(tmptable)]<-1
rownames(tmptable)<-union
integrated<-apply(tmptable,1,fisherp)
# Optional subsetting
toshow<-names(sort(integrated))
toshow<-toshow[grep(subsetting,toshow)]
toshow<-toshow[1:topn]
# Prepare input
resUP<--log10(res$up[toshow])
resDN<--log10(res$dn[toshow])
names(resUP)<-toshow
names(resDN)<-toshow
resUP[is.na(resUP)]<-0
resDN[is.na(resDN)]<-0
# Canvas
upperlim<-ceiling(max(c(resUP,resDN)))
par(mar=c(0,0,0,0))
plot(0,col="white",xlim=c(-10,12),ylim=c(-2,topn+3),xaxt="n",yaxt="n",type="n",frame.plot=FALSE,xlab="",ylab="",xaxs="i",yaxs="i")
# text(c(0:10),c(0:10),labels=c(0:10),pos=1,offset=0)
# text(c(1,2,2,1),c(1,2,1,2),labels=c("1_1","2_2","2_1","1_2"),pos=1,offset=0)
# Title
regsize<-length(regulon[[s2e(tf)]]$tfmode)
text(5,topn+2.8,paste0("Pathway enrichment of ",tf," regulon"),pos=1,offset=0,font=2)
text(5,topn+2,paste0("regulon size: ",regsize),pos=1,offset=0,font=3,cex=0.8)
# Axis horizontal
abline(h=0)
segments(0:10,0,0:10,-0.3)
text(5,-1,"Hypergeometric -log10(pvalue)",pos=1,offset=0)
text(1:10,-0.5,cex=0.7,
labels=round(signif(seq(0,upperlim,length.out=11)),2)[2:11]
)
# Axis vertical
abline(v=0)
#segments(0,topn:0,-0.3,topn:0)
# Significance line
abline(v=(-log10(0.05)/upperlim)*10,lty=2)
# Bars
for(i in topn:1){
upval<-(resUP[i]/upperlim)*10
dnval<-(resDN[i]/upperlim)*10
rect(0,i+0.25,upval,i,col="salmon")
rect(0,i,dnval,i-0.25,col="cornflowerblue")
}
# Pathway labels
pathlabels<-gsub(subsetting,"",toshow)
pathlabels<-tolower(pathlabels)
pathlabels<-gsub("_"," ",pathlabels)
for(i in topn:1){
text(0,i,pathlabels[i],pos=2,offset=0.1,cex=0.8)
}
# Canvas
upperlim<-ceiling(max(c(resUP,resDN)))
par(mar=c(0,0,0,0))
plot(0,col="white",xlim=c(-10,12),ylim=c(-2,topn+3),xaxt="n",yaxt="n",type="n",frame.plot=FALSE,xlab="",ylab="",xaxs="i",yaxs="i")
# Title
regsize<-length(regulon[[s2e(tf)]]$tfmode)
text(5,topn+2.8,paste0("Pathway enrichment of ",tf," regulon"),pos=1,offset=0,font=2)
plot(0,col="white",xlim=c(-10,12),ylim=c(-2,topn+3),xaxt="n",yaxt="n",type="n",frame.plot=FALSE,xlab="",ylab="",xaxs="i",yaxs="i")
# text(c(0:10),c(0:10),labels=c(0:10),pos=1,offset=0)
# Canvas
upperlim<-ceiling(max(c(resUP,resDN)))
par(mar=c(0,0,0,0))
plot(0,col="white",xlim=c(-10,12),ylim=c(-2,topn+3),xaxt="n",yaxt="n",type="n",frame.plot=FALSE,xlab="",ylab="",xaxs="i",yaxs="i")
tf<-"GRHL2"
regulon<-tcga_regulon
# Pathways
wass<-load("msigdb/MSigDB_v5.0_human.rda") # "msigDBentrez" "msigDBsymbol"
ngenes<-length(unique(unlist(msigDBentrez$c2.all.v5.0.entrez.gmt)))
### Hypergeometric test implementation
# Hypergeometric enrichment function
enrich<-function(list1,list2,pathway){
l1<-length(list1)
l2<-length(list2)
overlap<-length(intersect(list1,list2))
q<-overlap-1
m<-l1
n<-ngenes-l1
k<-l2
p<-phyper(q,m,n,k,lower.tail=FALSE,log.p=FALSE)
return(p)
}
# Fisher P integration function
fisherp<-function (ps) {
Xsq <- -2 * sum(log(ps))
p.val <- pchisq(Xsq, df = 2 * length(ps), lower.tail = FALSE)
return(p.val)
}
# Regulon vs. pathway
networkUP<-names(regulon[[s2e(tf)]]$tfmode)[regulon[[s2e(tf)]]$tfmode>=0]
networkDN<-names(regulon[[s2e(tf)]]$tfmode)[regulon[[s2e(tf)]]$tfmode<0]
### Enrichment Loop C2
fname<-paste0("results/004_results_hypergeom_C2_",tf,".rda")
#pathways<-msigDBentrez$c2.cp.biocarta.v5.0.entrez.gmt
pathways<-msigDBentrez$c2.all.v5.0.entrez.gmt
if(!file.exists(fname)){
results<-list()
ntests<-0
tfs<-names(regulon)
pb<-txtProgressBar(0,length(tfs),style=3)
pbi<-1
for(tf in tfs){
plimit<-0.05
setTxtProgressBar(pb,pbi)
sublistUP<-setNames(rep(NA,length(pathways)),names(pathways))
sublistDN<-setNames(rep(NA,length(pathways)),names(pathways))
i<-1
for(pathway in pathways){
networkUP<-names(regulon[[tf]]$tfmode)[regulon[[tf]]$tfmode>=0]
networkDN<-names(regulon[[tf]]$tfmode)[regulon[[tf]]$tfmode<0]
pUP<-enrich(networkUP,pathway,ngenes)
pDN<-enrich(networkDN,pathway,ngenes)
ntests<-ntests+1
sublistUP[i]<-pUP
sublistDN[i]<-pDN
i<-i+1
}
sublistUP<-sublistUP[sublistUP<=plimit]
sublistDN<-sublistDN[sublistDN<=plimit]
results[[tf]]<-list(up=sublistUP,dn=sublistDN)
pbi<-pbi+1
}
save(results,ntests,file=fname)
} else {
load(fname)
}
### Now, plotting
# Set parameters
topn<-20
subsetting<-"REACTOME_"
## Start plot
# Prepare input results
res<-results[[s2e(tf)]]
# Correct pvalues and integrate
resUP<-p.adjust(res$up,method="none",n=ntests) # convert to bonferroni when deploying
resDN<-p.adjust(res$dn,method="none",n=ntests)
union<-union(names(resUP),names(resDN))
tmptable<-cbind(resUP[union],resDN[union])
tmptable[is.na(tmptable)]<-1
rownames(tmptable)<-union
integrated<-apply(tmptable,1,fisherp)
# Optional subsetting
toshow<-names(sort(integrated))
toshow<-toshow[grep(subsetting,toshow)]
toshow<-toshow[1:topn]
# Prepare input
resUP<--log10(res$up[toshow])
resDN<--log10(res$dn[toshow])
names(resUP)<-toshow
names(resDN)<-toshow
resUP[is.na(resUP)]<-0
resDN[is.na(resDN)]<-0
# Canvas
upperlim<-ceiling(max(c(resUP,resDN)))
par(mar=c(0,0,0,0))
plot(0,col="white",xlim=c(-10,12),ylim=c(-2,topn+3),xaxt="n",yaxt="n",type="n",frame.plot=FALSE,xlab="",ylab="",xaxs="i",yaxs="i")
# text(c(0:10),c(0:10),labels=c(0:10),pos=1,offset=0)
# text(c(1,2,2,1),c(1,2,1,2),labels=c("1_1","2_2","2_1","1_2"),pos=1,offset=0)
# Title
regsize<-length(regulon[[s2e(tf)]]$tfmode)
text(5,topn+2.8,paste0("Pathway enrichment of ",tf," regulon"),pos=1,offset=0,font=2)
text(5,topn+2,paste0("regulon size: ",regsize),pos=1,offset=0,font=3,cex=0.8)
# Axis horizontal
abline(h=0)
segments(0:10,0,0:10,-0.3)
text(5,-1,"Hypergeometric -log10(pvalue)",pos=1,offset=0)
text(1:10,-0.5,cex=0.7,
labels=round(signif(seq(0,upperlim,length.out=11)),2)[2:11]
)
# Axis vertical
abline(v=0)
#segments(0,topn:0,-0.3,topn:0)
# Significance line
abline(v=(-log10(0.05)/upperlim)*10,lty=2)
# Bars
for(i in topn:1){
upval<-(resUP[i]/upperlim)*10
dnval<-(resDN[i]/upperlim)*10
rect(0,i+0.25,upval,i,col="salmon")
rect(0,i,dnval,i-0.25,col="cornflowerblue")
}
# Pathway labels
pathlabels<-gsub(subsetting,"",toshow)
pathlabels<-tolower(pathlabels)
pathlabels<-gsub("_"," ",pathlabels)
for(i in topn:1){
text(0,i,pathlabels[i],pos=2,offset=0.1,cex=0.8)
}
# Percentage of pathway overlap
r<-names(regulon[[s2e(tf)]]$tfmode)
percs<-c()
for(i in topn:1){
p<-pathways[[toshow[i]]]
intrsct<-intersect(p,r)
perc<-100*length(intrsct)/length(p)
percs<-c(percs,perc)
}
names(percs)<-rev(toshow)
spercs<-(percs/max(percs))*4
lines(spercs,topn:1,lty=1,lwd=2)
# Ruler of pathway overlap
segments(0,topn+1,4,topn+1)
text(2,topn+1.5,pos=1,offset=0,font=3,cex=0.7,labels="% pathway")
segments(0:4,topn+1,0:4,topn+0.8)
text(1:4,topn+0.65,cex=0.5,
labels=round(seq(0,max(percs),length.out=5),1)[2:5]
)
par<-par.backup
knitr::opts_chunk$set(echo=TRUE)
par.backup<-par()
```{r, fig.cap="Caption", message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo=TRUE)
knitr::opts_chunk$set(fig.align="center")
knitr::opts_chunk$set(fig.path = "rmarkdown_images/")
par.backup<-par()
set.seed(1)
#Figure and Table Caption Numbering, for HTML do it manually
captabNo <- 1; capfigNo <- 1;
#Function to add the Table Number
captab <- function(x){
x <- paste0("Table S",captabNo,". ",x)
captabNo <<- captabNo + 1
x
}
#Function to add the Figure Number
capfig <- function(x){
x <- paste0("Figure S",capfigNo,". ",x)
capfigNo <<- capfigNo + 1
x
}
#source("http://bioconductor.org/biocLite.R")
#biocLite("vulcan")
library(vulcan)
knitr::opts_chunk$set(echo=TRUE)
knitr::opts_chunk$set(fig.align="center")
knitr::opts_chunk$set(fig.path = "rmarkdown_images/")
par.backup<-par()
set.seed(1)
#Figure and Table Caption Numbering, for HTML do it manually
captabNo <- 1; capfigNo <- 1;
#Function to add the Table Number
captab <- function(x){
x <- paste0("Table S",captabNo,". ",x)
captabNo <<- captabNo + 1
x
}
#Function to add the Figure Number
capfig <- function(x){
x <- paste0("Figure S",capfigNo,". ",x)
capfigNo <<- capfigNo + 1
x
}
#source("http://bioconductor.org/biocLite.R")
#biocLite("vulcan")
library(vulcan)
library(gplots) # for heatmap.2
library(org.Hs.eg.db)
library(gridExtra) # for the pathway part
library(GeneNet) # to generate partial correlation networks
install.packages("GeneNet")
knitr::opts_chunk$set(echo=TRUE)
knitr::opts_chunk$set(fig.align="center")
knitr::opts_chunk$set(fig.path = "rmarkdown_images/")
par.backup<-par()
set.seed(1)
#Figure and Table Caption Numbering, for HTML do it manually
captabNo <- 1; capfigNo <- 1;
#Function to add the Table Number
captab <- function(x){
x <- paste0("Table S",captabNo,". ",x)
captabNo <<- captabNo + 1
x
}
#Function to add the Figure Number
capfig <- function(x){
x <- paste0("Figure S",capfigNo,". ",x)
capfigNo <<- capfigNo + 1
x
}
#source("http://bioconductor.org/biocLite.R")
#biocLite("vulcan")
library(vulcan)
library(gplots) # for heatmap.2
library(org.Hs.eg.db)
library(gridExtra) # for the pathway part
library(GeneNet) # to generate partial correlation networks
if(!file.exists("results")){dir.create("results")}
list_eg2symbol<-as.list(org.Hs.egSYMBOL[mappedkeys(org.Hs.egSYMBOL)])
e2s<-function(ids){
ids <- as.character(ids)
outlist <- list_eg2symbol[ids]
names(outlist) <- ids
outlist[is.na(outlist)] <- paste("unknown.", ids[is.na(outlist)], sep = "")
outlist <- gsub("unknown.unknown.", "", outlist)
return(outlist)
}
list_symbol2eg <- as.character(org.Hs.egSYMBOL2EG[mappedkeys(org.Hs.egSYMBOL2EG)])
s2e<-function(ids){
ids <- as.character(ids)
outlist <- list_symbol2eg[ids]
names(outlist) <- ids
outlist[is.na(outlist)] <- paste("unknown.", ids[is.na(outlist)], sep = "")
outlist <- gsub("unknown.unknown.", "", outlist)
return(outlist)
}
sheetfile<-"chipseq/holding/sheet.csv"
fname<-"results/001_input.rda"
if(!file.exists(fname)){
vobj<-vulcan.import(sheetfile)
save(vobj,file=fname)
} else {
load(fname)
}
vobj<-vulcan.annotate(vobj,lborder=-10000,rborder=10000,method="sum")
vobj<-vulcan.normalize(vobj)
save(vobj,file="results/001_vobj.rda")
heatmap.2(vobj$rawcounts,scale="row",
col=colorpanel(1000,"navy","white","red3"),tracecol="black",labRow="")
mtext("Raw Counts")
heatmap.2(vobj$normalized,
col=colorpanel(1000,"navy","white","red3"),tracecol="black",labRow="")
mtext("VST-normalized")
heatmap.2(vobj$rpkms,scale="row",
col=colorpanel(1000,"navy","white","red3"),tracecol="black",labRow="")
mtext("RPKMs")
topvar<-apply(vobj$normalized[,],1,var)
topvar<-sort(topvar,dec=TRUE)[1:500]
submat<-vobj$normalized[names(topvar),]
pca<-prcomp(t(submat))
vars<-100*(pca$sdev^2)/sum(pca$sdev^2)
vars<-signif(vars,3)
p1<-1
p2<-2
plot(pca$x[,p1],pca$x[,p2],
xlab=paste0("PC",p1," (Var.Explained: ",vars[p1],"%)"),
ylab=paste0("PC",p2," (Var.Explained: ",vars[p2],"%)"),
type="p",main="PC Analysis",pch=20,col="grey",
xlim=c(min(pca$x[,p1])*1.1,max(pca$x[,p1])*1.1)
)
mtext("VST-Normalized data",cex=0.8)
textplot2(pca$x[,p1],pca$x[,p2],new=FALSE,
words=gsub("_[0-9]","",rownames(pca$x),perl=TRUE)
)
grid()
p1<-1
p2<-5
plot(pca$x[,p1],pca$x[,p2],
xlab=paste0("PC",p1," (Var.Explained: ",vars[p1],"%)"),
ylab=paste0("PC",p2," (Var.Explained: ",vars[p2],"%)"),
type="p",main="PC Analysis",pch=20,col="grey",
xlim=c(min(pca$x[,p1])*1.1,max(pca$x[,p1])*1.1)
)
mtext("VST-Normalized data",cex=0.8)
textplot2(pca$x[,p1],pca$x[,p2],new=FALSE,
words=gsub("_[0-9]","",rownames(pca$x),perl=TRUE)
)
grid()
sheetfile<-"chipseq/holding/sheet.csv"
fname<-"results/001_diffbind.rda"
if(!file.exists(fname)){
# Load a sample sheet
chipseqSamples<-read.csv(sheetfile)
dbaobj<-dba(sampleSheet=chipseqSamples)
# Count reads 500bp either side of summits, a peak is considered a peak
# if it is found in 3 samples out of loaded samples.
dbaobj<-dba.count(dbaobj,minOverlap=3,summits=500)
# Define contrasts
dbaobj<-dba.contrast(dbaobj, categories=DBA_CONDITION)
# Calculate differential binding using the DESeq2 engine within DiffBind
dbaobj<-dba.analyze(dbaobj,method=DBA_DESEQ2)
# Save the DiffBind object
save(dbaobj,file=fname)
} else {
load(fname)
}
# Visualize each contrast
dba.contrast(dbaobj)
dba.plotMA(dbaobj,contrast=1,method=DBA_DESEQ2)
dba.plotMA(dbaobj,contrast=2,method=DBA_DESEQ2)
dba.plotMA(dbaobj,contrast=3,method=DBA_DESEQ2)
# Load imported vulcan object
load("results/001_vobj.rda")
# Vulcan Analysis (multiple networks)
## Networks
load("networks/laml-tf-regulon.rda")
laml_regulon<-regul
rm(regul)
load("networks/brca-tf-regulon.rda")
tcga_regulon<-regul
rm(regul)
load("networks/metabric-regulon-tfs.rda")
metabric_regulon<-regulon
rm(regulon)
names(vobj$samples)
fname<-"results/002_vobj_networks.rda"
list_eg2symbol<-as.list(org.Hs.egSYMBOL[mappedkeys(org.Hs.egSYMBOL)])
if(!file.exists(fname)){
vobj_tcga_90<-vulcan(vobj,network=tcga_regulon,contrast=c("t90","t0"),annotation=list_eg2symbol)
vobj_tcga_45<-vulcan(vobj,network=tcga_regulon,contrast=c("t45","t0"),annotation=list_eg2symbol)
vobj_metabric_90<-vulcan(vobj,network=metabric_regulon,contrast=c("t90","t0"),annotation=list_eg2symbol)
vobj_metabric_45<-vulcan(vobj,network=metabric_regulon,contrast=c("t45","t0"),annotation=list_eg2symbol)
vobj_negative_90<-vulcan(vobj,network=laml_regulon,contrast=c("t90","t0"),annotation=list_eg2symbol)
vobj_negative_45<-vulcan(vobj,network=laml_regulon,contrast=c("t45","t0"),annotation=list_eg2symbol)
save(
vobj_tcga_90,
vobj_tcga_45,
vobj_metabric_90,
vobj_metabric_45,
vobj_negative_90,
vobj_negative_45,
file=fname
)
} else {
load(fname)
}
threshold<-p2z(0.05)
metabric_90=vobj_metabric_90$mrs[,"NES"]
metabric_45=vobj_metabric_45$mrs[,"NES"]
tfs<-names(metabric_45)
metabricmat<-cbind(rep(0,length(metabric_45)),metabric_45[tfs],metabric_90[tfs])
colnames(metabricmat)<-c("T0","T45","T90")
## All TFs
matplot(t(metabricmat),type="l",col="grey",ylab="VULCAN NES",xaxt="n",lty=1,main="All TFs",xlim=c(1,3.3),ylim=c(min(metabricmat),max(metabricmat)))
axis(1,at=c(1:3),labels=colnames(metabricmat))
abline(h=c(0,threshold,-threshold),lty=2)
matplot(t(t(metabricmat["ESR1",])),type="l",col="red",lty=1,lwd=2,add=TRUE)
text(3,metabricmat["ESR1",3],label="ESR1",pos=4,cex=0.6,font=2,col="red3")
mtext("METABRIC network")
threshold<-p2z(0.05)
tfclass<-tfs[metabricmat[,"T45"]>=threshold&metabricmat[,"T90"]>=threshold]
matplot(t(metabricmat),type="l",col="grey",ylab="VULCAN NES",xaxt="n",lty=1,main="Early responders",xlim=c(1,3.3),ylim=c(0,max(metabricmat)))
axis(1,at=c(1:3),labels=colnames(metabricmat))
abline(h=c(0,threshold,-threshold),lty=2)
matplot(t(metabricmat[tfclass,]),type="l",col="red3",lty=1,lwd=2,add=TRUE)
# Repel a bit
plabels<-tfclass
oricoords<-sort(setNames(metabricmat[plabels,3],plabels))
newcoords<-setNames(seq(min(oricoords),max(oricoords),length.out=length(oricoords)),names(oricoords))
text(3,newcoords,label=names(oricoords),pos=4,cex=0.6,font=2)
text(3,newcoords["ESR1"],label="ESR1",pos=4,cex=0.6,font=2,col="red3")
mtext("METABRIC network")
threshold<-p2z(0.05)
tfclass<-tfs[metabricmat[,"T45"]<=-threshold&metabricmat[,"T90"]<=-threshold]
matplot(t(metabricmat),type="l",col="grey",ylab="VULCAN NES",xaxt="n",lty=1,main="Repressed TFs",xlim=c(1,3.3),ylim=c(min(metabricmat),0))
axis(1,at=c(1:3),labels=colnames(metabricmat))
abline(h=c(0,threshold,-threshold),lty=2)
matplot(t(metabricmat[tfclass,]),type="l",col="cornflowerblue",lty=1,lwd=2,add=TRUE)
# Repel a bit
plabels<-c(tfclass,"GRHL2")
oricoords<-sort(setNames(metabricmat[plabels,3],plabels))
newcoords<-setNames(seq(min(oricoords),max(oricoords),length.out=length(oricoords)),names(oricoords))
text(3,newcoords,label=names(oricoords),pos=4,cex=0.6,font=2)
mtext("METABRIC network")
plabels
biocLite()
install.package("genenet")
install.packages("genenet")
install.packages("GeneNet")
library(MSnbase)
MSnbase::select
conflicts()
conflicts("select")
sort(conflicts())
unlink('/Volumes/VULCAN/VULCAN/Manuscript_Figures_Combined_cache', recursive = TRUE)
warnings()
unlink('/Volumes/VULCAN/VULCAN/Manuscript_Figures_Combined_cache', recursive = TRUE)
